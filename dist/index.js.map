{"version":3,"sources":["../src/discovery.ts","../src/parser.ts","../src/site-config.ts","../src/sorting.ts","../src/loader.ts"],"sourcesContent":["import { glob } from \"glob\"\nimport path from \"node:path\"\n\nimport type { ContentType } from \"./schema.js\"\n\nexport interface DiscoveredFile {\n  filePath: string\n  slug: string\n  type: ContentType\n}\n\nexport async function discoverEntries(\n  contentDir: string,\n  type: ContentType,\n): Promise<DiscoveredFile[]> {\n  const pattern = `${type}/*/index.md`\n  const matches = await glob(pattern, { cwd: contentDir })\n\n  return matches.map((match) => {\n    const parts = match.split(\"/\")\n    return {\n      filePath: path.join(contentDir, match),\n      slug: parts[1],\n      type,\n    }\n  })\n}\n\nexport function buildEntryPath(\n  contentDir: string,\n  type: ContentType,\n  slug: string,\n): string {\n  return path.join(contentDir, type, slug, \"index.md\")\n}\n","import matter from \"gray-matter\"\nimport fs from \"node:fs/promises\"\n\nimport type { ContentEntry, ContentType, ContentTypeMap } from \"./schema.js\"\n\nexport async function parseEntry<T extends ContentType>(\n  filePath: string,\n  type: T,\n  slug: string,\n): Promise<ContentEntry<T> | null> {\n  try {\n    const raw = await fs.readFile(filePath, \"utf-8\")\n    const { data, content } = matter(raw)\n\n    if (data.date instanceof Date) {\n      data.date = data.date.toISOString().split(\"T\")[0]\n    }\n\n    const frontmatter = data as ContentTypeMap[T]\n\n    if (frontmatter.draft) {\n      return null\n    }\n\n    return {\n      slug,\n      type,\n      frontmatter,\n      content,\n    }\n  } catch {\n    return null\n  }\n}\n","import matter from \"gray-matter\"\nimport fs from \"node:fs/promises\"\nimport path from \"node:path\"\n\nimport type { SiteConfig } from \"./schema.js\"\n\nexport async function parseSiteConfig(\n  contentDir: string,\n): Promise<SiteConfig> {\n  const filePath = path.join(contentDir, \"site.yaml\")\n  const raw = await fs.readFile(filePath, \"utf-8\")\n  const wrapped = `---\\n${raw}\\n---`\n  const { data } = matter(wrapped)\n\n  return data as SiteConfig\n}\n","import type { ContentEntry, ContentType } from \"./schema.js\"\n\nexport function sortByDateDesc<T extends ContentType>(\n  entries: ContentEntry<T>[],\n): ContentEntry<T>[] {\n  return [...entries].sort((a, b) => {\n    const dateA = new Date(a.frontmatter.date).getTime()\n    const dateB = new Date(b.frontmatter.date).getTime()\n    return dateB - dateA\n  })\n}\n","import { buildEntryPath, discoverEntries } from \"./discovery.js\"\nimport { parseEntry } from \"./parser.js\"\nimport type {\n  ContentEntry,\n  ContentType,\n  ContentTypeMap,\n  SiteConfig,\n} from \"./schema.js\"\nimport { parseSiteConfig } from \"./site-config.js\"\nimport { sortByDateDesc } from \"./sorting.js\"\n\nexport interface ContentLoaderOptions {\n  contentDir: string\n}\n\nexport interface ContentLoader {\n  getEntries<T extends ContentType>(type: T): Promise<ContentEntry<T>[]>\n  getEntry<T extends ContentType>(\n    type: T,\n    slug: string,\n  ): Promise<ContentEntry<T> | null>\n  getAllTags(): Promise<string[]>\n  getEntriesByTag<T extends ContentType>(\n    type: T,\n    tag: string,\n  ): Promise<ContentEntry<T>[]>\n  getSlugs(type: ContentType): Promise<string[]>\n  getSiteConfig(): Promise<SiteConfig>\n}\n\nconst CONTENT_TYPES: ContentType[] = [\n  \"blog\",\n  \"linkedin\",\n  \"projects\",\n  \"til\",\n  \"snippets\",\n  \"thoughts\",\n  \"quotes\",\n  \"ideas\",\n]\n\nexport function createContentLoader(\n  options: ContentLoaderOptions,\n): ContentLoader {\n  const { contentDir } = options\n\n  async function getEntries<T extends ContentType>(\n    type: T,\n  ): Promise<ContentEntry<T>[]> {\n    const discovered = await discoverEntries(contentDir, type)\n\n    const parsed = await Promise.all(\n      discovered.map((file) => parseEntry<T>(file.filePath, type, file.slug)),\n    )\n\n    const entries = parsed.filter(\n      (entry): entry is ContentEntry<T> => entry !== null,\n    )\n\n    return sortByDateDesc(entries)\n  }\n\n  async function getEntry<T extends ContentType>(\n    type: T,\n    slug: string,\n  ): Promise<ContentEntry<T> | null> {\n    const filePath = buildEntryPath(contentDir, type, slug)\n    return parseEntry<T>(filePath, type, slug)\n  }\n\n  async function getAllTags(): Promise<string[]> {\n    const allTags = new Set<string>()\n\n    for (const type of CONTENT_TYPES) {\n      const entries = await getEntries(type)\n      for (const entry of entries) {\n        for (const tag of entry.frontmatter.tags) {\n          allTags.add(tag)\n        }\n      }\n    }\n\n    return [...allTags].sort()\n  }\n\n  async function getEntriesByTag<T extends ContentType>(\n    type: T,\n    tag: string,\n  ): Promise<ContentEntry<T>[]> {\n    const entries = await getEntries(type)\n    return entries.filter((entry) => entry.frontmatter.tags.includes(tag))\n  }\n\n  async function getSlugs(type: ContentType): Promise<string[]> {\n    const discovered = await discoverEntries(contentDir, type)\n    return discovered.map((file) => file.slug)\n  }\n\n  async function getSiteConfig(): Promise<SiteConfig> {\n    return parseSiteConfig(contentDir)\n  }\n\n  return {\n    getEntries,\n    getEntry,\n    getAllTags,\n    getEntriesByTag,\n    getSlugs,\n    getSiteConfig,\n  }\n}\n"],"mappings":"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","names":["matter","fs","path"]}